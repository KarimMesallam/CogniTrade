#!/usr/bin/env python
"""
Strategy Comparison Script

This script demonstrates how to use the BacktestRunner to compare different
trading strategies. It analyzes trade logs generated by the backtesting module
and provides educational insights about different trading approaches.
"""

import os
import sys
import logging
from datetime import datetime, timedelta
import pandas as pd
import matplotlib.pyplot as plt
import sqlite3

# Add parent directory to path to import bot modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from bot.backtesting import BacktestEngine, BacktestRunner
from bot.binance_api import client
from bot.config import API_KEY, API_SECRET, TESTNET, SYMBOL
from bot.strategy import calculate_rsi, calculate_bollinger_bands

# Create logs directory if it doesn't exist
os.makedirs('logs', exist_ok=True)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/strategy_comparison.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("trading_bot")

# Define strategies for comparison
def sma_crossover_strategy(data_dict, symbol):
    """
    Simple Moving Average Crossover Strategy
    
    Buy when short SMA crosses above long SMA
    Sell when short SMA crosses below long SMA
    """
    # Use 1h timeframe data
    timeframe = '1h'
    if timeframe not in data_dict:
        return 'HOLD'
        
    df = data_dict[timeframe]
    
    # Require enough data
    if len(df) < 50:
        return 'HOLD'
    
    # Calculate SMAs
    short_period = 10
    long_period = 30
    
    df['sma_short'] = df['close'].rolling(window=short_period).mean()
    df['sma_long'] = df['close'].rolling(window=long_period).mean()
    
    # Get current and previous values
    current = df.iloc[-1]
    previous = df.iloc[-2]
    
    # Check for crossover
    if previous['sma_short'] <= previous['sma_long'] and current['sma_short'] > current['sma_long']:
        return 'BUY'
    elif previous['sma_short'] >= previous['sma_long'] and current['sma_short'] < current['sma_long']:
        return 'SELL'
    else:
        return 'HOLD'

def rsi_strategy(data_dict, symbol):
    """
    RSI Strategy
    
    Buy when RSI crosses above oversold threshold
    Sell when RSI crosses below overbought threshold
    """
    # Use 4h timeframe data
    timeframe = '4h'
    if timeframe not in data_dict:
        return 'HOLD'
        
    df = data_dict[timeframe]
    
    # Require enough data
    if len(df) < 30:
        return 'HOLD'
    
    # Check for RSI column
    if 'rsi' not in df.columns:
        return 'HOLD'
    
    # Define thresholds
    oversold = 30
    overbought = 70
    
    # Get current and previous RSI
    current_rsi = df['rsi'].iloc[-1]
    previous_rsi = df['rsi'].iloc[-2]
    
    # Buy signal: RSI crosses from below oversold to above oversold
    if previous_rsi < oversold and current_rsi > oversold:
        return 'BUY'
    
    # Sell signal: RSI crosses from above overbought to below overbought
    elif previous_rsi > overbought and current_rsi < overbought:
        return 'SELL'
    
    # No signal
    else:
        return 'HOLD'

def bollinger_band_strategy(data_dict, symbol):
    """
    Bollinger Band Strategy
    
    Buy when price touches lower band
    Sell when price touches upper band
    """
    # Use 1h timeframe data
    timeframe = '1h'
    if timeframe not in data_dict:
        return 'HOLD'
        
    df = data_dict[timeframe]
    
    # Require enough data
    if len(df) < 30:
        return 'HOLD'
    
    # Check for Bollinger Band columns
    if 'upper_band' not in df.columns or 'lower_band' not in df.columns:
        return 'HOLD'
    
    # Get current values
    current_close = df['close'].iloc[-1]
    current_upper = df['upper_band'].iloc[-1]
    current_lower = df['lower_band'].iloc[-1]
    
    # Buy signal: Price at or below lower band
    if current_close <= current_lower * 1.01:  # 1% tolerance
        return 'BUY'
    
    # Sell signal: Price at or above upper band
    elif current_close >= current_upper * 0.99:  # 1% tolerance
        return 'SELL'
    
    # No signal
    else:
        return 'HOLD'

def run_strategy_comparison():
    """Run multiple backtests with different strategies and compare results"""
    
    # Parameters for backtest
    symbol = SYMBOL  # Use the symbol from .env
    timeframes = ['1h', '4h']  # Use multiple timeframes
    
    # Use a 60-day period for backtesting
    end_date = datetime.now().strftime('%Y-%m-%d')
    start_date = (datetime.now() - timedelta(days=60)).strftime('%Y-%m-%d')
    
    print(f"\n=== Running Strategy Comparison ===")
    print(f"Symbol: {symbol}")
    print(f"Timeframes: {', '.join(timeframes)}")
    print(f"Period: {start_date} to {end_date}")
    
    try:
        # Try to ping Binance to verify connection
        client.ping()
        print("Successfully connected to Binance API")
        
        # Create a backtest runner
        runner = BacktestRunner()
        
        # First, let's ensure we have data available
        print("Checking if historical data is available...")
        engine = BacktestEngine(
            symbol=symbol,
            timeframes=timeframes,
            start_date=start_date,
            end_date=end_date
        )

        # Download data if needed
        data_available = True
        for timeframe in timeframes:
            if timeframe not in engine.market_data or engine.market_data[timeframe].empty:
                print(f"Downloading {timeframe} data for {symbol}...")
                try:
                    # Convert dates to millisecond timestamps
                    start_ts = int(pd.Timestamp(start_date).timestamp() * 1000)
                    end_ts = int(pd.Timestamp(end_date).timestamp() * 1000)
                    
                    # Get klines data from Binance
                    klines = client.get_historical_klines(
                        symbol=symbol,
                        interval=timeframe,
                        start_str=str(start_ts),
                        end_str=str(end_ts)
                    )
                    
                    if not klines:
                        print(f"No data returned for {symbol} at {timeframe} timeframe")
                        data_available = False
                        continue
                    
                    # Convert to DataFrame
                    df = pd.DataFrame(klines, columns=[
                        'timestamp', 'open', 'high', 'low', 'close', 'volume',
                        'close_time', 'quote_asset_volume', 'number_of_trades',
                        'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
                    ])
                    
                    # Convert timestamps to datetime
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
                    
                    # Convert numeric columns
                    numeric_cols = ['open', 'high', 'low', 'close', 'volume']
                    df[numeric_cols] = df[numeric_cols].apply(pd.to_numeric)
                    
                    # Select only the columns required by the database schema
                    # and add symbol and timeframe
                    df_filtered = df[['timestamp', 'open', 'high', 'low', 'close', 'volume']].copy()
                    df_filtered['symbol'] = symbol
                    df_filtered['timeframe'] = timeframe
                    
                    # Store in database (proper way)
                    try:
                        with sqlite3.connect(engine.db.db_path) as conn:
                            # Insert data, replacing any existing entries
                            df_filtered['timestamp'] = df_filtered['timestamp'].dt.strftime('%Y-%m-%d %H:%M:%S')
                            df_filtered.to_sql('market_data', conn, if_exists='append', index=False)
                            print(f"Successfully stored {len(df_filtered)} candles in database")
                    except Exception as e:
                        print(f"Database error: {e}")
                        # Even if DB storage fails, we can still use the in-memory data
                    
                    # Update engine's market data regardless of DB storage success
                    engine.market_data[timeframe] = df
                    print(f"Using data for {timeframe} ({len(df)} candles)")
                    
                except Exception as e:
                    print(f"Error downloading data: {e}")
                    data_available = False
                    continue

        if not data_available:
            print("Could not download all required historical data. Cannot proceed with comparison.")
            return None, None, None

        # Define strategies to test
        strategies = {
            'SMA_Crossover': sma_crossover_strategy,
            'RSI': rsi_strategy,
            'Bollinger_Bands': bollinger_band_strategy
        }
        
        print(f"\nTesting {len(strategies)} strategies: {', '.join(strategies.keys())}")
        
        # Run multiple backtests
        results = runner.run_multiple_backtests(
            symbols=[symbol],
            timeframes=timeframes,
            strategies=strategies,
            start_date=start_date,
            end_date=end_date,
            initial_capital=10000
        )
        
        # Compare strategies
        comparison = runner.compare_strategies()
        
        # Generate summary report
        report = runner.generate_summary_report(output_file='logs/strategy_comparison_report.txt')
        
        # Print the report
        print("\n=== Strategy Comparison Results ===")
        print(report)
        
        # Create custom visualization for educational purposes
        create_educational_visualization(results, comparison, symbol)
        
        return results, comparison, report
        
    except Exception as e:
        print(f"Error running strategy comparison: {e}")
        logger.error(f"Strategy comparison error: {e}", exc_info=True)
        return None, None, None

def create_educational_visualization(results, comparison, symbol):
    """
    Create an educational visualization comparing the strategies
    
    This extends the standard visualizations with educational annotations
    """
    if not results or not comparison.empty:
        # Get strategy results for the given symbol
        symbol_results = results.get(symbol, {})
        
        if symbol_results:
            # Create figure
            plt.figure(figsize=(15, 10))
            
            # Plot equity curves for each strategy
            plt.subplot(2, 1, 1)
            
            for strategy_name, strategy_data in symbol_results.items():
                if 'result' in strategy_data and 'equity_curve' in strategy_data['result']:
                    equity_data = pd.DataFrame(strategy_data['result']['equity_curve'])
                    plt.plot(equity_data['timestamp'], equity_data['equity'], label=strategy_name)
            
            plt.title('Equity Curves: Strategy Comparison')
            plt.ylabel('Equity ($)')
            plt.grid(True)
            plt.legend()
            
            # Create educational annotations
            plt.subplot(2, 1, 2)
            plt.axis('off')
            
            strategy_descriptions = {
                'SMA_Crossover': [
                    'Trend-following strategy that uses moving averages',
                    'Pros: Works well in trending markets, easy to understand',
                    'Cons: Lags in sideways markets, can produce false signals'
                ],
                'RSI': [
                    'Mean-reversion strategy using Relative Strength Index',
                    'Pros: Identifies potential reversals, works in range-bound markets',
                    'Cons: Can fail during strong trends, requires parameter tuning'
                ],
                'Bollinger_Bands': [
                    'Volatility-based strategy using standard deviations',
                    'Pros: Adapts to changing market conditions, defines overbought/oversold',
                    'Cons: Band touches don\'t always lead to reversals, false signals'
                ]
            }
            
            # Create text box with strategy descriptions
            text_content = 'STRATEGY INSIGHTS:\n\n'
            
            # Add performance data
            for _, row in comparison.iterrows():
                strategy = row['strategy']
                text_content += f"--- {strategy} ---\n"
                text_content += f"Return: {row['total_return_pct']:.2f}%, Win Rate: {row['win_rate']:.2f}%\n"
                text_content += f"Sharpe: {row['sharpe_ratio']:.2f}, Trades: {row['total_trades']}\n"
                
                # Add description
                if strategy in strategy_descriptions:
                    for line in strategy_descriptions[strategy]:
                        text_content += f"• {line}\n"
                text_content += '\n'
            
            # Add market suitability info
            text_content += "MARKET SUITABILITY:\n"
            text_content += "• Trending Markets: SMA Crossover > Bollinger Bands > RSI\n"
            text_content += "• Range-Bound Markets: RSI > Bollinger Bands > SMA Crossover\n"
            text_content += "• Volatile Markets: Bollinger Bands > RSI > SMA Crossover\n"
            
            plt.text(0.1, 0.9, text_content, va='top', fontsize=10, 
                    bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))
            
            # Save figure
            plt.tight_layout()
            plt.savefig('logs/strategy_comparison_educational.png')
            print("Educational visualization saved to logs/strategy_comparison_educational.png")

def print_educational_insights():
    """Print educational insights about trading strategies"""
    
    print("\n==== TRADING STRATEGY EDUCATIONAL INSIGHTS ====\n")
    
    print("1. SMA CROSSOVER STRATEGY")
    print("   ------------------------------")
    print("   ✓ Description: The Simple Moving Average (SMA) crossover strategy buys when a shorter-period")
    print("     moving average crosses above a longer-period moving average, and sells when it crosses below.")
    print("   ✓ Theory: This strategy aims to capture trends. The short-term SMA represents recent price")
    print("     action, while the long-term SMA represents the longer-term trend.")
    print("   ✓ Advantages:")
    print("     - Simple to understand and implement")
    print("     - Effective in trending markets")
    print("     - Reduces emotional decision-making")
    print("   ✓ Disadvantages:")
    print("     - Lag due to the nature of moving averages")
    print("     - Many false signals in choppy/sideways markets")
    print("     - Suboptimal entry/exit points (often late)")
    print("   ✓ Best Market Conditions: Strong trending markets with minimal volatility")
    print("   ✓ Typical Parameters: Short MA (10-20 periods), Long MA (50-200 periods)")
    
    print("\n2. RSI STRATEGY")
    print("   ------------------------------")
    print("   ✓ Description: The Relative Strength Index (RSI) strategy buys when the RSI indicator drops")
    print("     below an oversold level (typically 30) and then rises back above it. It sells when RSI rises")
    print("     above an overbought level (typically 70) and then drops below it.")
    print("   ✓ Theory: This strategy aims to identify potential reversals by measuring the speed and change")
    print("     of price movements. RSI values above 70 indicate overbought conditions, while values below 30")
    print("     indicate oversold conditions.")
    print("   ✓ Advantages:")
    print("     - Good at identifying potential reversal points")
    print("     - Works well in ranging markets")
    print("     - Can catch significant price movements at turning points")
    print("   ✓ Disadvantages:")
    print("     - Unreliable during strong trends (false signals)")
    print("     - RSI can remain in extreme zones during strong trends")
    print("     - Requires more interpretation than SMA")
    print("   ✓ Best Market Conditions: Ranging/consolidating markets with clear support/resistance levels")
    print("   ✓ Typical Parameters: Period (14), Overbought (70), Oversold (30)")
    
    print("\n3. BOLLINGER BANDS STRATEGY")
    print("   ------------------------------")
    print("   ✓ Description: Bollinger Bands strategy uses upper and lower bands (typically 2 standard")
    print("     deviations from a moving average) to identify overbought and oversold conditions.")
    print("   ✓ Theory: Price tends to return to the mean. When price touches the upper band, it may be")
    print("     overbought; when it touches the lower band, it may be oversold.")
    print("   ✓ Advantages:")
    print("     - Bands adapt to market volatility")
    print("     - Works in both trending and ranging markets")
    print("     - Provides visual reference for support and resistance")
    print("   ✓ Disadvantages:")
    print("     - Band touches don't always lead to reversals")
    print("     - Can produce premature signals in strong trends")
    print("     - Requires confirmation from other indicators")
    print("   ✓ Best Market Conditions: Markets with changing volatility, transitions between ranges and trends")
    print("   ✓ Typical Parameters: 20-period SMA with 2 standard deviation bands")
    
    print("\n4. STRATEGY COMBINATIONS")
    print("   ------------------------------")
    print("   ✓ Combining strategies often produces better results than using any single approach:")
    print("     - SMA + RSI: Use trend direction from SMA with RSI for timing entries/exits")
    print("     - Bollinger Bands + RSI: Use band touches confirmed by RSI extremes")
    print("     - Triple Screen: Use longer timeframe for trend, shorter for entry timing")
    print("   ✓ Other effective combinations:")
    print("     - Price action + indicators: Combine candlestick patterns with technical indicators")
    print("     - Multiple timeframe analysis: Confirm signals across different timeframes")
    
    print("\n5. RISK MANAGEMENT PRINCIPLES")
    print("   ------------------------------")
    print("   ✓ Position Sizing: Never risk more than 1-2% of your capital on a single trade")
    print("   ✓ Stop Loss: Always use stops to protect against unexpected market moves")
    print("   ✓ Risk/Reward Ratio: Aim for at least 1:2 (risk one to make two)")
    print("   ✓ Correlation: Be careful trading correlated assets in the same direction")
    print("   ✓ Expectancy: Focus on your system's expectancy (win rate × average win - loss rate × average loss)")
    
    print("\n==== NEXT STEPS FOR LEARNING ====")
    print("1. Experiment with strategy parameters to optimize performance")
    print("2. Test strategies on different market conditions and symbols")
    print("3. Implement combinations of strategies for confirmation")
    print("4. Add proper position sizing and risk management")
    print("5. Keep detailed records of all trades for ongoing improvement")

if __name__ == "__main__":
    print("\n=== Strategy Comparison Tool ===")
    # Option 1: Run a new comparison
    run_comparison = True
    
    if run_comparison:
        results, comparison, report = run_strategy_comparison()
    
    # Print educational insights
    print_educational_insights()
    
    print("\nStrategy comparison complete! Check logs directory for results.") 